---
name: projectmanagement
description: Use when managing project initiatives through full lifecycle from initiation to closing - provides artifact types, templates, and phase-based workflow for organizing complex work across teams with basicmemory integration
---

## Overview

Project management skill provides a complete lifecycle framework for managing initiatives through seven phases: Initiation, Planning (Stories), Planning (Tasks), Delegation, Execution, Monitoring, and Closing. Each phase has validation gates and mandatory artifact creation to prevent ad-hoc approaches.

**Core principle:** All project artifacts must be stored in basicmemory under a ProjectId, with explicit linking and status tracking to maintain single source of truth across concurrent projects.

## When to Use This Skill

Use this skill when:

- Managing a project or major initiative with multiple phases
- Need to coordinate work across team members
- Creating Epics, Specs, Stories, or Tasks
- Organizing artifacts consistently across concurrent projects
- Need to track dependencies, decisions, and research
- Running retrospectives or closing out projects
- Struggling with ad-hoc project organization

Do NOT use this skill for:

- One-off tasks or quick fixes (no artifact overhead needed)
- Personal task tracking (use simpler tools)
- Formal Agile/Scrum implementation (this is lightweight, not framework-specific)

## Requirements:

- use basicmemory mcp tools to read and write [Project Artifacts].
- Recognise types of [Project Artifacts]: [Spec], [Research], [Descision], [Epic], [Story], [Task], [Retrospective].
- Store [Project Artifacts] in basicmemory under the correct project context using [ProjectId].

## What are Project Artifact Types?

- [Epic]: A large body of work that is described by Stories. An [Epic] is always accompanied by a [Spec], they have a 1:1 relationship.
- [Spec]: A detailed description of the project's requirements and objectives. It leads to creation of one or more [Story].
- [Research]: Information gathering and analysis conducted to inform project decisions. [Research] can lead to or adjust creation of [Spec] and/or [Decision]. Created ad-hoc when questions need investigation; linked to relevant [Spec], [Decision], [Story], or [Task].
- [Decision]: A conclusion reached after evaluating options, often based on [Research]. [Decision] can influence [Spec] and project direction. Created during Initiation/Planning (for strategic decisions) or during Execution (for implementation decisions). Status must be "Decided" or "Unresolved". All [Decision] artifacts with status "Unresolved" MUST be linked to the [Retrospective] during the Closing phase.
- [Story]: A smaller, manageable piece of work derived from an [Epic]. [Story] always contain "user stories". [Story] are always implemented by [Task].
- [Task]: A specific piece of work that needs to be completed as part of a [Story]. They are always linked to both a [Story] and an [Epic]. They can also be linked to other [Task] in interesting ways (e.g., blocking, dependent on, related to).

## Project Artifacts Require a ProjectId [CRITICAL]

Every [Project Artifact] must be associated with a [ProjectId] to ensure proper organization and retrieval.

We use this [ProjectId] when first interacting with basicmemory. (Or if required, on every interaction)

### ProjectId Naming and Format

**ProjectId Convention:**

- Format: `slugified-project-name` (kebab-case, lowercase alphanumeric + hyphens)
- Source: Derived from git repository name or project name
- Generated by: `./scripts/get_project_id.sh` (automatically slugifies)
- Examples:
  - Repository: `github.com/username/dotfiles` → ProjectId: `dotfiles`
  - Project name: "User Authentication System" → ProjectId: `user-authentication-system`
  - Example name "My App v2" → ProjectId: `my-app-v2`

### ProjectId Setup

1. Identify the [ProjectId] using `./scripts/get_project_id.sh`
2. Create a basicmemory project using `basicmemory_create_memory_project(name="{ProjectId}", project_path="~/Notes/Projects/{ProjectId}")`
3. Use this [ProjectId] in ALL subsequent interactions with basicmemory to read or write [Project Artifacts].

## Where are [Project Artifacts] stored?

**CRITICAL** All [Project Artifacts] are interacted with via basicmemory mcp tools.
**FAILURE MODE** Interacting with [Project Artifacts] via the file system directly is not allowed and will lead to disorganization and loss of data.

- basicmemory_read_note - Read markdown notes
- basicmemory_read_content - Read file raw content by path
- basicmemory_view_note - View formatted notes
- basicmemory_write_note - Create/update markdown notes
- basicmemory_edit_note - Edit existing notes with operations
- basicmemory_move_note - Move notes to new locations
- basicmemory_delete_note - Delete notes by title
- basicmemory_canvas - Create Obsidian canvas files
- basicmemory_search_notes - Search across knowledge base
- basicmemory_search - Search for content across knowledge base
- basicmemory_fetch - Fetch full contents of search results
- basicmemory_recent_activity - Get recent activity
- basicmemory_build_context - Build context from memory URIs
- basicmemory_list_memory_projects - List all available projects
- basicmemory_create_memory_project - Create new projects
- basicmemory_delete_project - Delete projects
- basicmemory_list_directory - List directory contents
- basicmemory_sync_status - Check file sync status

## How do we store Project Artifacts in basicmemory?

This skill has access to templates for each artifact type.

- [Epic]: ./references/templates/epic_template.md
- [Spec]: ./references/templates/spec_template.md
- [Research]: ./references/templates/research_template.md
- [Decision]: ./references/templates/decision_template.md
- [Story]: ./references/templates/story_template.md
- [Task]: ./references/templates/task_template.md
- [Retrospective]: ./references/templates/retrospective_template.md

When creating or updating [Project Artifacts], use the corresponding template to ensure consistency.

## Artifact Storage Structure (Johnny Decimal System)

### Naming Convention

All artifacts follow the Johnny Decimal naming system for consistent organization and human readability:

```
{epicid}.{typecode}.{incrementid}-{typename}-{title}.md
```

**Components:**

- **{epicid}** - Epic identifier (0001, 0002, 0003, ...) - zero-padded
  - Identifies which epic the artifact belongs to
  - ALL artifacts except Retrospective must have an epic
  
- **{typecode}** - Artifact type code (fixed)
  - `1` = Spec
  - `2` = Research
  - `3` = Decision
  - `4` = Story
  - `5` = Task
  - `9` = Retrospective (project-level only, epic id is 0000)

- **{incrementid}** - Increment counter (0001, 0002, 0003, ...) - zero-padded
  - Increments per epic+type combination
  - Spec: Always 0001 per epic (one spec per epic)
  - Research: 0001, 0002, 0003... per epic
  - Decision: 0001, 0002, 0003... per epic
  - Story: 0001, 0002, 0003... per epic
  - Task: 0001, 0002, 0003... per epic

- **{typename}** - Human-readable type (spec, research, decision, story, task, retrospective)

- **{title}** - Human-readable title in kebab-case (e.g., user-authentication-requirements)

### Examples

| Artifact | Filename | Meaning |
|----------|----------|---------|
| Epic 1 Spec | `0001.1.0001-spec-user-auth-requirements.md` | Epic 1, Spec, 1st (only) |
| Epic 1 Research | `0001.2.0001-research-oauth-alternatives.md` | Epic 1, Research, 1st |
| Epic 1 Research | `0001.2.0002-research-jwt-best-practices.md` | Epic 1, Research, 2nd |
| Epic 1 Decision | `0001.3.0001-decision-jwt-vs-session.md` | Epic 1, Decision, 1st |
| Epic 1 Story | `0001.4.0001-story-user-login-flow.md` | Epic 1, Story, 1st |
| Epic 1 Task | `0001.5.0001-task-database-schema-design.md` | Epic 1, Task, 1st |
| Epic 2 Spec | `0002.1.0001-spec-api-security.md` | Epic 2, Spec, 1st (only) |
| Retrospective | `0000.9.0001-retrospective-project-closeout.md` | Project-level, Retrospective |

### Folder Structure

All artifacts are stored in basicmemory under a project folder with the following structure:

```
basicmemory/{ProjectId}/
│
├── {epicid}-{epic-name}/                    # Epic folder (groups related artifacts)
│   ├── {epicid}.1.0001-spec-{title}.md      # Spec file (only one per epic)
│   ├── {epicid}.2.0001-research-{title}.md  # Research files (multiple)
│   ├── {epicid}.2.0002-research-{title}.md
│   ├── {epicid}.3.0001-decision-{title}.md  # Decision files (multiple)
│   ├── {epicid}.3.0002-decision-{title}.md
│   ├── {epicid}.4.0001-story-{title}.md     # Story files (multiple)
│   └── {epicid}.4.0002-story-{title}.md
│
├── {epicid}.5.0001-task-{title}.md          # Task files at project level
├── {epicid}.5.0002-task-{title}.md
├── {epicid}.5.0003-task-{title}.md
│
└── 0000.9.0001-retrospective-{title}.md     # Project-level retrospective
```

**Why this structure:**

- ✅ **Visual hierarchy by path:** Human immediately sees which epic, which type, which order
- ✅ **Type visible in filename:** No ambiguity - `0001.3.0001` is clearly a decision
- ✅ **Johnny Decimal standard:** Familiar numbering system, naturally sorts in order
- ✅ **Epic folders group work:** All specs, research, decisions, stories for an epic in one folder
- ✅ **Tasks at project level:** Not nested, but epic/story IDs in filename show relationships
- ✅ **Human readable:** Title at end explains purpose at a glance
- ✅ **Operational oversight:** Manager opens folder, immediately sees all work organized

### Real Example: User Authentication System

```
basicmemory/user-auth-system/
│
├── 0001-user-authentication/
│   ├── 0001.1.0001-spec-user-authentication-requirements.md
│   ├── 0001.2.0001-research-oauth-alternatives.md
│   ├── 0001.2.0002-research-jwt-best-practices.md
│   ├── 0001.3.0001-decision-jwt-vs-session.md
│   ├── 0001.3.0002-decision-password-hashing-algorithm.md
│   ├── 0001.4.0001-story-user-login-flow.md
│   ├── 0001.4.0002-story-user-password-reset.md
│   └── 0001.4.0003-story-account-recovery.md
│
├── 0001.5.0001-task-design-database-schema.md
├── 0001.5.0002-task-implement-jwt-middleware.md
├── 0001.5.0003-task-create-login-api-endpoint.md
├── 0001.5.0004-task-create-password-reset-endpoint.md
├── 0001.5.0005-task-implement-frontend-auth-integration.md
├── 0001.5.0006-task-add-session-timeout-logic.md
│
├── 0002-api-rate-limiting/
│   ├── 0002.1.0001-spec-api-rate-limiting-requirements.md
│   ├── 0002.2.0001-research-rate-limiting-strategies.md
│   ├── 0002.3.0001-decision-token-bucket-vs-sliding-window.md
│   ├── 0002.4.0001-story-implement-rate-limiting.md
│   └── 0002.4.0002-story-add-rate-limit-headers.md
│
├── 0002.5.0001-task-implement-rate-limiter-middleware.md
├── 0002.5.0002-task-add-redis-caching.md
├── 0002.5.0003-task-monitoring-rate-limit-metrics.md
│
└── 0000.9.0001-retrospective-project-closeout.md
```

### Important Constraint: All Artifacts Belong to an Epic

Every artifact MUST be associated with an epic (except Retrospective):

- ✅ **Spec:** Always 1 per epic (0001.1.0001, 0002.1.0001, etc.)
- ✅ **Research:** Multiple per epic (0001.2.0001, 0001.2.0002, etc.)
- ✅ **Decision:** Multiple per epic (0001.3.0001, 0001.3.0002, etc.)
- ✅ **Story:** Multiple per epic (0001.4.0001, 0001.4.0002, etc.)
- ✅ **Task:** Multiple per epic (0001.5.0001, 0001.5.0002, etc.)
- ✅ **Retrospective:** Project-level, not tied to specific epic (0000.9.0001)

This ensures no orphaned artifacts and clear lineage from epic down to task.

### Obsidian Linking

All artifacts use Obsidian wiki-style linking for navigation and relationship management:

```markdown
[[{epicid}-{epic-name}]]           # Link to epic folder
[[{epicid}.{typecode}.{incrementid}-{typename}-{title}]]  # Link to artifact
```

Examples:
- `[[0001-user-authentication]]` - Links to Epic 1 folder
- `[[0001.1.0001-spec-user-authentication-requirements]]` - Links to specific spec
- `[[0001.5.0001-task-design-database-schema]]` - Links to specific task

See individual artifact templates for linking examples in frontmatter and body.

## Effort Estimation Hierarchy

[Epic], [Story], and [Task] have different estimation levels:

### [Epic] Estimation

- Estimated in **weeks or months** (high-level)
- Derived from Story points of child [Story] (sum all stories)
- Used for: Timeline planning, resource allocation
- Refinement: As [Story] are created and estimated

### [Story] Estimation

- Estimated in **story points** (3-13 points typical range)
- Based on: Complexity, risk, dependencies
- Used for: Release planning, sprint capacity
- Refinement: During Planning phase before creating [Task]

### [Task] Estimation

- Estimated in **story points** (1-8 points)
- Based on: Specific implementation work, clear acceptance criteria
- Constraint: If [Task] > 8 points, it should be split into smaller [Task]
- Used for: Day-to-day execution, capacity planning, identifying blockers
- Refinement: Continuous during Execution as understanding grows

**Why this hierarchy matters:**

- Epic scale helps executives understand project timeline
- Story scale helps team understand sprint commitment
- Task scale helps individual contributors understand daily work
- Misalignment = surprises (story was "5 points" but contained "3x13 point tasks")

## How are [Task] relationships described?

[Task] can be linked to other [Task] in interesting ways. Choose the relationship type that best describes the interaction:

### Task Relationship Types

**When to use "blocking":**

- THIS Task must finish BEFORE other Task can start
- Use: Document dependencies for critical path analysis
- Example: "Database schema design blocks API implementation"
- From Task perspective: "This task blocks: api-task-001"

**When to use "dependent_on":**

- THIS Task cannot start UNTIL another Task finishes
- Use: Identify what's blocking your progress
- Example: "API implementation depends on database schema design"
- From Task perspective: "This task is dependent_on: database-task-001"
- Note: "blocking" and "dependent_on" are the same relationship viewed from opposite directions

**When to use "related_to":**

- THIS Task is connected but does NOT have direct dependency
- Use: Track work in same area (e.g., similar components, same feature)
- Example: "Frontend auth task is related to backend auth task" (parallel, not blocking)
- Use sparingly - don't link everything

**When to use "duplicate_of":**

- THIS Task is a duplicate of another [Task]
- Use: When duplicate work is discovered, mark the duplicate and consolidate
- Example: "This task is duplicate_of: auth-task-002"
- Action: Cancel this task, redirect work to the original

**Linking to [Research] or [Decision]:**

- "influenced_by_research": This task was shaped by investigation/analysis
- "influenced_by_decision": This task was created based on a decision made
- Use: For traceability and understanding "why was this built this way?"

**Parent artifact links (MANDATORY):**

- Every [Task] MUST link to: parent [Story] AND parent [Epic]
- This establishes the hierarchy and enables queries like "all tasks in this epic"

## Artifact Status Transitions

Each artifact type has valid status progressions:

### [Epic] Status Flow

```
Active → (work in progress) → Completed
      ↘ (if deprioritized) → On Hold
      ↘ (if cancelled) → Cancelled
```

- **Active**: Project is underway
- **On Hold**: Work paused temporarily, can be resumed
- **Completed**: All child Stories and Tasks are done
- **Cancelled**: Project will not be completed

### [Spec] Status Flow

```
Draft → In Review → Approved
    ↘ (if rejected) → Draft (back to refinement)
    ↘ (if superseded) → Superseded (replaced by new spec)
```

- **Draft**: Being written, may have [NEEDS CLARIFICATION] tags
- **In Review**: Awaiting approval, all clarifications resolved
- **Approved**: Ready for Planning phase
- **Superseded**: Replaced by a newer version (link to new spec)

### [Story] Status Flow

```
To Do → In Progress → In Review → Done
    ↘ (if deprioritized) → Cancelled
    ↘ (if blocked) → Blocked (until unblocked)
```

- **To Do**: Ready for execution
- **In Progress**: Work started, at least one Task is in progress
- **In Review**: Work complete, awaiting acceptance
- **Done**: All acceptance criteria met, approved
- **Blocked**: Waiting on external dependency (document what blocks it)

### [Task] Status Flow

```
To Do → In Progress → In Review → Done
    ↘ (if blocked) → Blocked (until unblocked)
    ↘ (if deprioritized) → Cancelled
```

- **To Do**: Ready for work
- **In Progress**: Being actively worked on
- **In Review**: Code/work complete, awaiting approval
- **Done**: Definition of Done checklist complete
- **Blocked**: Waiting on another Task or external blocker (document reason)

### [Decision] Status Flow

```
Pending → Decided
      ↘ Unresolved (decision made but uncertain, needs revisiting)
      ↘ Superseded (replaced by new decision)
```

- **Pending**: Awaiting decision (analysis in progress)
- **Decided**: Decision made and documented
- **Unresolved**: Decision made but confidence low OR decision deferred (MUST review in Retrospective)
- **Superseded**: Original decision overridden by new decision (link to new decision)

### [Research] Status Flow

```
In Progress → Complete
          ↘ Inconclusive (insufficient data or unable to reach conclusion)
          ↘ Superseded (replaced by more recent research)
```

- **In Progress**: Research underway
- **Complete**: Findings documented and analysis complete
- **Inconclusive**: Investigation complete but conclusion unclear (document why)
- **Superseded**: Newer research or findings available (link to new research)

### [Retrospective] Status Flow

```
In Progress → Complete
```

- **In Progress**: Retrospective meeting underway, collecting feedback
- **Complete**: All feedback documented, action items assigned, lessons documented

### [Task] relationship schema

```markdown
---
title: { Task Title }
projectId: { ProjectId }
storyId: { Parent Story ID }
epicId: { Parent Epic ID }
status: { To Do | In Progress | Done | Blocked }
storyPoints: { Number of story points }
links:
  - type: blocking | dependent_on | related_to | duplicate_of
    ItemItem: { Linked Task ID }
  - type: influenced_by
    ItemItem: { Research or Decision ID }
---

{Task Body}
```

### [Task] content

The body of a [Task] is different depending on the type.

**[EPIC]**

Links:

- to a single [Spec].
- to one or more [Story].
- to one or more [Task] via linked [Story].

- Preamble.
- (heading) Objectives
- (heading) Scope
- (heading) Success Criteria

**[SPEC]**

Links:

- to a single [Epic].
- to one or more [Story].
- to one or more [Research].
- to one or more [Decision].

- Detailed preamble.
- (heading) Requirements
- (heading) Objectives
- (heading) Constraints
- (heading) Assumptions
- (heading) Success Criteria

**[STORY]**

Links:

- to a single [Epic].
- to a single [Spec].
- to one or more [Task].
- to one or more [Research].
- to one or more [Decision].

- Scenario description.
- (heading) User Stories (in BDD format)
- (heading) Acceptance Criteria

**[TASK]**

Links:

- to a single [Story].
- to a single [Epic].
- to other [Task] (blocking, dependent on, related to, duplicate of).
- to one or more [Research].
- to one or more [Decision].

- Specific work item description.
- (heading) Implementation Steps
- (heading) Out of Scope
- (heading) Definition of Done
- (heading) Notes
- (heading) Work Log (to be filled during execution)
- (heading) QA Testing Steps (to be filled out during execution)

## What is the lifecycle of a project initiative?

1. Initiation: Define the project at a high level, including objectives and scope. Create an [Epic] and associated [Spec].
   - Identify [ProjectId] using `./scripts/get_project_id.sh`
   - Create basicmemory project if it does not exist: `basicmemory_create_memory_project`
   - Create an [Epic] artifact to represent the initiative using epic_template.md
   - Create a [Spec] artifact to detail the requirements and objectives using spec_template.md. Mark any unknowns as [NEEDS CLARIFICATION]. [Research] artifacts can be created to gather more information.
   - Link the [Spec] to the [Epic] using frontmatter links.
   - Discuss and refine the [Spec] using a Conversational TodoList until all major points are resolved.
   - **SPEC APPROVAL GATE** (REQUIRED before moving to Planning):
     - Who approves: Product Owner, Tech Lead, or designated Spec Reviewer
     - Approval method: Documented in [Spec] frontmatter (approver name + date)
     - Approval criteria: All [NEEDS CLARIFICATION] tags resolved, all requirements stated, no open questions
     - If not approved: Return to refinement, create [Research] artifacts as needed
   - VALIDATION (Checklist must be completed before moving to next phase):
     - [ ] Ensure the [Epic] has a linked [Spec].
     - [ ] Ensure the [Spec] clearly outlines objectives and scope.
     - [ ] No remaining [NEEDS CLARIFICATION] tags in the [Spec].
     - [ ] Spec has been formally approved (documented with approver name + date).
     - [ ] Conversational TodoList contains no unresolved topics.

2. Planning: Break down the [Epic] into one or more [Story].

- Create [Story] artifacts for each major feature or requirement outlined in the [Spec].
- Link each [Story] to the [Epic] and [Spec].
- Link any [Research] or [Decision] artifacts that influenced the creation of the [Story].
- For each [Story], ensure it contains "user stories" that follow the BDD format (As a {user}, I want {feature}, so that {benefit}).
- VALIDATION (Checklist must be completed before moving to next phase):
  - [ ] Each [Story] is linked to the [Epic] and [Spec].
  - [ ] Each [Story] contains "user stories" in BDD format.
  - [ ] All major features from the [Spec] are covered by a [Story].

3. Planning: Break down each [Story] into required amount of [Task].

- Read the [Spec] and related [Story] to identify specific work items.
- Consider any [Research] or [Decision] that impact [Task] creation.
- A delivery schedule which outlines priorities for each [Task] will guide you declaring the order and dependencies.
- Consider "story points" or effort estimates for each [Task] to help with scheduling and resource allocation. Use fibonacci sequence for "story points" (1, 2, 3, 5, 8, 13, etc.).
- If a [Task] can be broken down further, split it into smaller atomic [Task]. Story points can help determine this:
  - If a [Task] is more than 8 story points, consider breaking it down.
  - If a [Task] is less than 3 story points, consider combining it with another related [Task]. But only if it doesn't violate the atomicity principle and if it makes sense contextually.
- Create one or more [Task] artifacts for each [Story], detailing the specific work needed to implement the [Story].
- Link each [Task] to its parent [Story] and [Epic].
- **CRITICAL PATH ANALYSIS**: Identify blocking and dependent-on relationships between [Task]:
  - "Blocking" = This [Task] must complete BEFORE other [Task] can start (blocks others)
  - "Dependent on" = This [Task] relies on another [Task] completing first (blocks this one)
  - Use frontmatter links to establish these relationships
  - Identify critical path (longest chain of dependent [Task]) - this determines minimum project duration
  - Flag any [Task] with 3+ blockers or dependencies as high-risk (escalate if needed)
- VALIDATION (Checklist must be completed before moving to next phase):
  - [ ] Delivered outputs of [Task] must usable and not interupt the user experience.
  - [ ] [Task] much be atomic, meaning they cannot be broken down further.
  - [ ] [Story] points must be assigned to each [Task].
  - [ ] Each [Task] is linked to its parent [Story] and [Epic].
  - [ ] Blocking/dependent relationships are documented for all interdependent [Task].
  - [ ] Critical path has been identified and its duration documented.
  - [ ] All [Story] have associated [Task] covering all implementation aspects.

4. Delegation: Assign Tasks to team members.

**use `skills_superpowers_dispatching_parallel_agents` and `skills_superpowers_subagent_driven_development` to manage team members and assignments.**

- Review the list of [Task] created in the previous phase.
- Consider the skills, availability, and workload of each team member.
- Request the agent communicate via the `sessions*` tools.
- Communicate assignments clearly, providing any necessary context or resources.
- Delegate work [Task] to the most suitable team member using the `task` tools.
- VALIDATION (Checklist must be completed before moving to next phase):
  - [ ] All [Task] have been assigned to team members.
  - [ ] Team members have acknowledged their assignments.
  - [ ] No team member is overloaded with [Task] beyond their capacity.

5. Execution: Implement the delegated [Task]. (Executed by subagent)
   - [BLOCKED] If you are blocked. Stop and discuss with the user "[WARNING] BLOCKED"
   - [STARTING] If you are starting a new [Task] use `skills_superpowers_using-git-worktrees` to create a new worktree for the [Task].
   - [CONTINUING] If you are continuing a [Task] use `skills_superpowers_using-git-worktrees` to switch to the existing worktree for the [Task].
   - Work on the [Task] as per the defined priorities and schedule.
   - Update the status of [Task] as they progress (e.g., To Do, In Progress, Done, Blocked).
   - Document any [Decision] made during implementation as [Decision] artifacts, linking them to relevant [Story] or [Task].
   - Completion of each [task]
   - If implementing a task uncovers unexpected information:
     - New requirements: Stop and discuss with the user "[WARNING] EDGE CASE DISCOVERED"
     - Unresolved decisions: Document them as [Decision] artifacts with status "Unresolved".
     - Blockers: Update the [Task] status to "Blocked" and link to the blocking Task. Discuss with the user.
   - VALIDATION (Checklist must be completed before moving to next phase):
     - [ ] All [Task] are marked as Done.
     - [ ] All work completed meets the Definition of Done criteria.
     - [ ] Any Decisions made are documented and linked appropriately.
     - [ ] No [Task] remain in Blocked status without resolution plans.

6. Monitoring and Controlling: Oversee project progress and make adjustments as needed.
   - Regularly review the status of all [Task] and overall project progress.
   - Respond to questions and issues raised by team members via `sessions*` tools.
   - Ensure that project stays on track with respect to timelines and objectives.
   - Update [Project Artifacts] as necessary to reflect changes or new information.
   - Identify any deviations from the plan and implement corrective actions:
     - If a [Task] is falling behind schedule, discuss with the assigned team member to understand the cause and adjust timelines or resources as needed.
     - If new risks are identified, document them and develop mitigation strategies.
     - Communicate any significant changes to the project plan to all stakeholders (the user).
   - VALIDATION (Checklist must be completed before moving to next phase):
     - [ ] Regular status updates are provided to the user.
     - [ ] Any deviations from the plan are documented and addressed.
     - [ ] [Project Artifacts] are kept up-to-date with the latest information.

7. Closing and Retrospective: Complete the project and document lessons learned.
   - Conduct a [Retrospective] meeting with team members to review the project outcomes.
   - Review all completed [Task], [Story], and [Epic] artifacts.
   - Document all lessons learned, including:
     - What went well during the project.
     - What could be improved for future projects.
     - Key challenges and how they were resolved.
   - Link any unresolved [Decision] artifacts (status "Unresolved") to the [Retrospective].
   - Document any process improvements or recommendations for future initiatives.
   - Create a [Retrospective] artifact summarizing the review and outcomes.
   - Archive or close all related [Project Artifacts].
   - VALIDATION (Checklist must be completed before closing project):
     - [ ] [Retrospective] artifact has been created and documented.
     - [ ] All unresolved [Decision] artifacts have been linked to the [Retrospective].
     - [ ] Lessons learned have been documented comprehensively.
     - [ ] [Project Artifacts] have been properly archived or closed.
